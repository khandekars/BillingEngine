Dockerizing a Spring Boot application involves packaging your application, its dependencies, and a Java Runtime Environment (JRE) into a lightweight, portable Docker image. This allows you to run your application consistently across different environments.


Here's a step-by-step guide to Dockerize your Spring Boot application:

Prerequisites
Docker Desktop: Make sure you have Docker Desktop installed and running on your machine. You can download it from docker.com.
Your Spring Boot Application: Ensure your Spring Boot application is complete and can be built into a runnable JAR file.
Step 1: Build Your Spring Boot Application into a JAR
Navigate to your project's root directory in your terminal and build the executable JAR file.

Bash

# For Maven
mvn clean install -DskipTests

# For Gradle
# gradle clean bootJar -x test
This command will compile your code, run the tests (unless -DskipTests or -x test is used), and package your application into a JAR file, typically located in the target/ directory (for Maven) or build/libs/ directory (for Gradle). The JAR name will usually be your-app-name-version.jar (e.g., h2-demo-0.0.1-SNAPSHOT.jar).

Step 2: Create a Dockerfile
A Dockerfile is a script that contains a series of instructions for building a Docker image. Create a file named Dockerfile (no file extension) in the root directory of your Spring Boot project, alongside your pom.xml (or build.gradle).


We'll use a multi-stage build for efficiency. This helps keep the final Docker image size small by separating the build environment from the runtime environment.

Dockerfile

# --- STAGE 1: Build the application ---
FROM maven:3.9-eclipse-temurin-17 AS builder

# Set the working directory inside the container
WORKDIR /app

# Copy the pom.xml (and build.gradle if using Gradle) and download dependencies
# This step is optimized to leverage Docker cache: if pom.xml doesn't change,
# dependencies won't be re-downloaded.
COPY pom.xml .
RUN mvn dependency:go-offline -B

# Copy the rest of the source code
COPY src ./src

# Build the application, skipping tests to make the image build faster
# The -DskipTests flag is important for Docker builds; run tests separately if needed.
RUN mvn clean install -DskipTests

# --- STAGE 2: Create the final lightweight runtime image ---
# Use a smaller JRE (Java Runtime Environment) image
# 'eclipse-temurin:17-jre-focal' is a good choice for Java 17 JRE on Ubuntu Focal
FROM eclipse-temurin:17-jre-focal

# Set the working directory for the runtime environment
WORKDIR /app

# Copy only the built JAR file from the 'builder' stage into the final image
# 'app.jar' is a common convention for the application JAR inside the container
COPY --from=builder /app/target/*.jar app.jar

# Expose the port that your Spring Boot application runs on (default is 8080)
EXPOSE 8080

# Define the command to run your application when the container starts
# 'java -jar app.jar' is the standard way to run a Spring Boot executable JAR
ENTRYPOINT ["java", "-jar", "app.jar"]

# You can also specify JVM memory arguments here for production.
# For example: ENTRYPOINT ["java", "-Xmx512m", "-jar", "app.jar"]
Step 3: Create a .dockerignore file (Highly Recommended)
Similar to .gitignore, a .dockerignore file tells Docker what files and directories to exclude when building the image. This prevents unnecessary files from being copied into the build context, speeding up builds and reducing image size.

Create a file named .dockerignore in your project's root directory:

# Exclude common IDE and build tool files
.mvn/
.gradle/
.idea/
.vscode/

# Exclude build output directories
target/
build/

# Exclude Git related files
.git/
.gitignore
README.md

# Exclude other common files
*.iml
*.log
Dockerfile
docker-compose.yml